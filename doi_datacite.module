<?php

/**
 * @file
 * Contains the doi_datacite.module.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\node\Entity\Node;

/**
 * Implements hook_form_alter().
 */
function doi_datacite_form_alter(&$form, FormStateInterface &$form_state, $form_id) {
  if ($form_id == 'persistent_identifiers_admin_settings') {
    $config = \Drupal::config('doi_datacite.settings');
    $form['doi_datacite_api_endpoint'] = [
      '#type' => 'textfield',
      '#access' => TRUE,
      '#title' => t('DataCite API endpoint'),
      '#default_value' => $config->get('doi_datacite_api_endpoint'),
      '#description' => t("The DataCite API endpoint URL. Include the trailing /."),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_prefix'] = [
      '#type' => 'textfield',
      '#access' => TRUE,
      '#title' => t('DOI prefix'),
      '#default_value' => $config->get('doi_datacite_prefix'),
      '#description' => t("Your institution's DOI prefix. Include the trailing /."),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_suffix_source'] = [
      '#type' => 'radios',
      '#access' => TRUE,
      '#title' => t('Source of DOI prefix'),
      '#options' => ['pid' => 'PID', 'uuid' => 'UUID'],
      '#default_value' => $config->get('doi_datacite_suffix_source'),
      '#description' => t("Use either the object's node ID or its UUID as the DOI suffix."),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_username'] = [
      '#type' => 'textfield',
      '#access' => TRUE,
      '#title' => t('DataCite API username'),
      '#default_value' => $config->get('doi_datacite_username'),
      '#description' => t("Your DataCite API username"),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_password'] = [
      '#type' => 'textfield',
      '#access' => TRUE,
      '#title' => 'DataCite API password',
      '#default_value' => $config->get('doi_datacite_password'),
      '#description' => t("Your DataCite API password"),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];
    $form['doi_datacite_combine_creators'] = [
      '#type' => 'checkbox',
      '#access' => TRUE,
      '#title' => t("Combine DC.creator and DC.contributor values"),
      '#default_value' => $config->get('doi_datacite_combine_creators'),
      '#description' => t("Check this option if you want to use both the object's DC.creator
        and DC.contributor values to populate DataCite's reqiured 'creator' element."),
      '#states' => [
        'visible' => [
          ':input[id="persistent_identifiers_minter"]' => ['value' => 'doi_datacite.minter.datacitedois'],
        ],
      ],
    ];

    $form['#submit'][] = 'doi_datacite_submit';
  }
}

/**
 * Implements hook_form_node_form_alter().
 */
function doi_datacite_form_node_form_alter(&$form, FormStateInterface $form_state) {
  if (\Drupal::currentUser()->hasPermission('mint persistent identifiers')) {
    $minter = Drupal::config('persistent_identifiers.settings')->get('persistent_identifiers_minter');
    if ($minter == 'doi_datacite.minter.datacitedois') {
      // DataCite requires the use of this following controlled list of resource types.
      // Note that the value(s) of this list is not stored anywhere, nor is it validated
      // by Drupal's Form API as required.
      $resource_type_values = [
        'Audiovisual' => 'Audiovisual',
        'Collection' => 'Collection',
        'Dataset' => 'Dataset',
        'Event' => 'Event',
        'Image' => 'Image',
        'InteractiveResource' => 'InteractiveResource',
        'Model' => 'Model',
        'PhysicalObject' => 'PhysicalObject',
        'Service' => 'Service',
        'Software' => 'Software',
        'Sound' => 'Sound',
        'Text' => 'Text',
        'Workflow' => 'Workflow',
        'Other' => 'Other',
      ];
      // Only show this form element if the user checks the "Mint DataCite DOI" box.
      $form['doi_datacite_resource_types'] = [
        '#type' => 'fieldset',
        '#access' => TRUE,
        '#title' => t('DataCite-specific options'),
        '#weight' => 90,
        '#states' => [
          'visible' => [
            ':input[id="persistent_identifiers_mint_and_persist"]' => ['checked' => TRUE],
          ],
        ],
      ];
      $form['doi_datacite_resource_types']['doi_datacite_resource_type'] = [
        '#type' => 'radios',
        '#options' => $resource_type_values,
        '#access' => TRUE,
        '#title' => t("DataCite resource types"),
        '#description' => t("Metadata submitted to DataCite requires one of these " .
	"resource types."),
      ];
      $form['#validate'][] = 'doi_datacite_check_for_required_datacite_elements';
    }
  }
}

/**
 * Submit callback.
 *
 * Saves the value of the minter-specific field defined in the implementation
 * of hook_form_alter() above.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function doi_datacite_submit(array &$form, FormStateInterface $form_state) {
  $minter = Drupal::config('persistent_identifiers.settings')->get('persistent_identifiers_minter');
  if ($minter == 'doi_datacite.minter.datacitedois') {
    $endpoint = trim($form_state->getValue('doi_datacite_api_endpoint'));
    $prefix = trim($form_state->getValue('doi_datacite_prefix'));
    $suffix_source = $form_state->getValue('doi_datacite_suffix_source');
    $username = trim($form_state->getValue('doi_datacite_username'));
    $password = trim($form_state->getValue('doi_datacite_password'));
    $combine_creator = $form_state->getValue('doi_datacite_combine_creators');
    $config_factory = \Drupal::configFactory();
    $config_factory->getEditable('doi_datacite.settings')
      ->set('doi_datacite_api_endpoint', $endpoint)
      ->set('doi_datacite_prefix', $prefix)
      ->set('doi_datacite_suffix_source', $suffix_source)
      ->set('doi_datacite_username', $username)
      ->set('doi_datacite_password', $password)
      ->set('doi_datacite_combine_creators', $combine_creator)
      ->save();
  }
}

/**
 * Form validation callback.
 *
 * Checks to see if the elements required by DataCite are populated.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function doi_datacite_check_for_required_datacite_elements(array $form, FormStateInterface &$form_state) {
  if (\Drupal::currentUser()->hasPermission('mint persistent identifiers')) {
    // We only want to validate these elements if the "Mint DataCite DOI" checkbox is checked.
    if ($form_state->getValue('mint_and_persist') == 1) {
      $minter = Drupal::config('persistent_identifiers.settings')->get('persistent_identifiers_minter');
      if ($minter == 'doi_datacite.minter.datacitedois') {
	// DataCite resource type.
        if (empty($form_state->getValue('doi_datacite_resource_type'))) {
          $form_state->setErrorByName('doi_datacite_resource_type', t('You must choose a DataCite resource type.'));
	}
	// @todo: These are required by DataCite.
	// Publication date
	// At least one creator
	// Publisher
      }
    }
  }
}

/**
 * Implements hook_theme().
 */
function doi_datacite_theme() {
  return [
    'doi_datacite_metadata' => [
      'variables' => [
        'entity' => NULL,
        'doi' => NULL,
        'extra' => NULL,
      ],
    ],
  ];
}

/**
 * Default preprocessor function for the doi_datacite_metadata hook.
 */
function template_preprocess_doi_datacite_metadata(&$variables) {
  $entity = $variables['entity'];
  // Don't need this anymore.
  unset($variables['entity']);

  $variables['title'] = $entity->getTitle();
  $descriptions = $entity->get('field_description')->getValue();
  $variables['description'] = $descriptions[0];

  // Perform these checks when $extra comes from node edit form. Preprocessors
  // should perform appropriate checks to determine if $exta is coming from
  // a Drush, depending on what form $extra takes (associative array, etc.).
  if (is_object($variables['extra']) && method_exists($variables['extra'], 'getValue')) {
    $variables['resource_type'] = $variables['extra']->getValue('doi_datacite_resource_type');
  }

  // var_export($variables['extra']);

  /*
   * @todo: Populate these template variables from node field data.
  $variables['creators'] =
  $variables['publisher'] =
  $variables['publication_year'] =
  $variables['subjects'] =
  $variables['languages'] =
  */
}
